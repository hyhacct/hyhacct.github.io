[{"id":"2fa26015fca5f58433a95c9ef360f007","title":"记录下Vue中的try及Promise异常处理","content":"try...catch 结构\n.then().catch() 结构\n这两种结构都是用来处理异常的，但是有些不同，这里做个文档记录下，方便日后 CV\ntry 结构\n名称： try-catch 块\n作用： 用于处理同步代码中的异常。当 try 块中的代码执行时，如果发生异常，程序会跳过剩余的 try 块代码，直接执行 catch 块中的代码。示例：\n\n1234567891011121314let x = 10;try &#123;  let y = 20;  console.log(x + y); // 输出 30  // ...&#125; catch (error) &#123;  console.error(error);  let z = 30; // z 只在 catch 块内有效&#125; finally &#123;  console.log(&quot;Finally block executed&quot;);&#125;console.log(z); // 报错，因为 z 仅在 catch 块内有效\n\ntry 块:\n\n作为独立的执行上下文。\n在 try 块中声明的变量仅在 try 块内有效。\n\ncatch 块:\n\n作为 try 块的子作用域。\n在 catch 块中声明的变量仅在 catch 块内有效。\n\nfinally 块:\n\n作为 try…catch 的子作用域。\n无论 try 或 catch 是否执行，finally 块都会执行。\n在 finally 块中声明的变量也仅在 finally 块内有效。\n\nPromise 结构\n名称： Promise 的 then 和 catch 方法\n作用： 用于处理异步操作的结果。Promise 是一个代表异步操作最终完成（或失败）的对象，而 then 和 catch 方法则分别用于处理成功和失败的情况。\n\n1234567891011fetch(&quot;/api/data&quot;)  .then((response) =&gt; response.json())  .then((data) =&gt; &#123;    console.log(&quot;成功获取数据:&quot;, data);  &#125;)  .catch((error) =&gt; &#123;    console.error(&quot;获取数据失败:&quot;, error);  &#125;)  .finally(() =&gt; &#123;    console.log(&quot;数据请求完成&quot;);  &#125;);\n\nthen():\n\n当 Promise 对象的状态变为 fulfilled（成功）时，就会调用 then 方法指定的回调函数。\n\ncatch():\n\n当 Promise 对象的状态变为 rejected（失败）时，就会调用 catch 方法指定的回调函数。\n\nfinally():\n\n无论 Promise 对象的状态是 fulfilled 还是 rejected，finally 方法指定的回调函数都会执行。\n\n","slug":"2025-07-19-05","date":"2025-07-19T14:49:21.000Z","categories_index":"Vue.js","tags_index":"Vue.js 异常处理","author_index":"Reverse"},{"id":"46e84f5dfeda8b84f00edf3fa860badf","title":"Vue表单规则","content":"rules 规则是 Vue.js 中非常重要的属性，它可以对表单的输入进行校验，并给出提示信息, 这里浅浅的记录一下有关 rules 规则的常用用法。\n基础用法rules 规则是一个数组，数组的每一项是一个对象，对象中包含两个属性：\n\n\n\n属性名称\n功能描述\n\n\n\nmessage\n当验证失败时显示的错误信息\n\n\ntrigger\n指定何时触发验证，常见的值有 blur（失去焦点时）、change（值发生变化时）\n\n\ntype\n指定数据类型，如 string、number、email 等\n\n\nmin 和 max\n用于限制输入的最小和最大长度\n\n\npattern\n使用正则表达式进行验证\n\n\nvalidator\n自定义验证函数，允许你编写更复杂的验证逻辑\n\n\nrequired\n是否必填，值为 true 或 false。\n\n\n例如：\n12345rules: [  &#123; required: true, message: &quot;不能为空&quot; &#125;,  &#123; min: 6, max: 12, message: &quot;长度必须在6到12之间&quot; &#125;,  &#123; pattern: /^[a-zA-Z]+$/, message: &quot;只能输入字母&quot; &#125;,];\n\n上述例子中，第一个规则表示必填，第二个规则表示长度必须在 6 到 12 之间，第三个规则表示只能输入字母。\n123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;  &lt;n-form ref=&quot;formRef&quot; label-placement=&quot;left&quot; :label-width=&quot;80&quot; :model=&quot;formValue&quot; :rules=&quot;rules&quot;&gt;    &lt;n-form-item label=&quot;节点名称&quot; path=&quot;name&quot;&gt;      &lt;n-input v-model:value=&quot;formValue.name&quot; placeholder=&quot;请输入节点名称&quot; /&gt;    &lt;/n-form-item&gt;    &lt;n-form-item label=&quot;节点类型&quot; path=&quot;type&quot;&gt;      &lt;n-select v-model:value=&quot;formValue.type&quot; :options=&quot;OptionsType&quot; placeholder=&quot;请选择&quot; /&gt;    &lt;/n-form-item&gt;    &lt;n-form-item label=&quot;运营商&quot; path=&quot;operator&quot;&gt;      &lt;n-select v-model:value=&quot;formValue.operator&quot; :options=&quot;OptionsOperator&quot; placeholder=&quot;请选择&quot; /&gt;    &lt;/n-form-item&gt;    &lt;n-form-item label=&quot;调度类型&quot; path=&quot;dispatch&quot;&gt;      &lt;n-select v-model:value=&quot;formValue.dispatch&quot; :options=&quot;OptionsDispatch&quot; placeholder=&quot;请选择&quot; /&gt;    &lt;/n-form-item&gt;  &lt;/n-form&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const showModal = true;const formValue = ref(&#123;  name: &quot;&quot;,  type: null,  operator: null,  dispatch: null,&#125;);const rules = &#123;  name: [    &#123; required: true, message: &quot;请输入节点名称&quot;, trigger: &quot;blur&quot; &#125;,    &#123; min: 2, max: 20, message: &quot;长度在 2 到 20 个字符&quot;, trigger: &quot;blur&quot; &#125;,  ],  type: [&#123; required: true, message: &quot;请选择节点类型&quot;, trigger: &quot;change&quot; &#125;],  operator: [&#123; required: true, message: &quot;请选择运营商&quot;, trigger: &quot;change&quot; &#125;],  dispatch: &#123; required: true, message: &quot;请选择调度类型&quot;, trigger: [&quot;blur&quot;, &quot;change&quot;, &quot;input&quot;], type: &quot;array&quot; &#125;,&#125;;&lt;/script&gt;\n\ntrigger 触发介绍\n\n\n\n\n\n\n\n\n在表单验证中，blur、change 和 input 是常见的事件，用于触发验证逻辑。下面分别介绍这三个事件的含义和用途，以及一些其他可能用到的事件。\ninput 事件\n\n含义：每当输入框的内容发生变化时，立即触发验证。\n用途：适用于需要实时反馈的场景，例如用户在输入过程中，希望立即看到输入内容是否符合要求。这可以提供即时的用户体验，帮助用户及时纠正错误。\n示例：用户在输入邮箱地址时，每次键入一个字符，都会触发验证，检查邮箱格式是否正确。\n\nblur 事件\n\n含义：当输入框失去焦点时触发验证。\n用途：适用于用户完成输入并离开输入框后进行验证。这可以减少不必要的验证调用，提高性能，同时在用户完成输入后提供验证结果。\n示例：用户在输入姓名后，点击其他地方或切换到其他输入框，此时触发验证，检查姓名是否为空。\n\nchange 事件\n\n含义：当输入框的内容发生变化并且输入框失去焦点时触发验证。\n用途：适用于需要在用户完成输入并离开输入框后进行验证的场景，但与 blur 事件不同的是，change 事件只有在内容实际发生变化后才会触发。\n示例：用户在输入密码后，点击其他地方或切换到其他输入框，如果密码内容发生了变化，才会触发验证，检查密码是否符合要求。\n\nfocus 事件\n\n含义：当输入框获得焦点时触发。\n用途：可以用于初始化一些状态或显示提示信息。\n示例：用户点击输入框时，显示一个提示信息，提示用户输入的内容要求。\n\nkeyup 事件\n\n含义：当用户松开键盘上的键时触发。\n用途：可以用于需要在用户完成键入操作后立即进行验证的场景。\n示例：用户在输入搜索关键词时，每次松开键时触发搜索建议的显示。\n\nkeydown 事件\n\n含义：当用户按下键盘上的键时触发。\n用途：可以用于需要在用户开始键入时进行一些操作的场景，例如限制输入内容。\n示例：用户在输入数字输入框时，按下非数字键时阻止输入。\n\nkeypress 事件\n\n含义：当用户按下键盘上的键并产生字符值时触发。\n用途：可以用于需要在用户输入字符时进行一些操作的场景，但现代开发中通常推荐使用 input 事件。\n示例：用户在输入文本时，每次输入字符时进行一些处理，例如自动格式化输入内容。\n\n总结\n\n\n事件\n总结\n\n\n\ninput\n实时反馈，每次内容变化时触发。\n\n\nblur\n用户完成输入并离开输入框时触发。\n\n\nchange\n用户完成输入并离开输入框且内容发生变化时触发。\n\n\nfocus\n输入框获得焦点时触发，用于初始化状态或显示提示。\n\n\nkeyup\n用户松开键时触发，用于需要在键入操作完成后立即进行的操作。\n\n\nkeydown\n用户按下键时触发，用于需要在键入操作开始时进行的操作。\n\n\nkeypress\n用户按下键并产生字符值时触发，现代开发中推荐使用 input 事件。\n\n\n通过按钮触发验证123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt;  &lt;el-form ref=&quot;formRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;&gt;    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;      &lt;el-input v-model=&quot;form.username&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;      &lt;el-input type=&quot;password&quot; v-model=&quot;form.password&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;handleValidateButtonClick&quot;&gt;验证&lt;/el-button&gt;  &lt;/el-form&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;import &#123; ElMessage as message &#125; from &quot;element-plus&quot;;const formRef = ref(null);const form = ref(&#123;  username: &quot;&quot;,  password: &quot;&quot;,&#125;);const rules = &#123;  username: [&#123; required: true, message: &quot;请输入用户名&quot;, trigger: &quot;blur&quot; &#125;],  password: [    &#123; required: true, message: &quot;请输入密码&quot;, trigger: &quot;blur&quot; &#125;,    &#123; min: 6, message: &quot;密码长度至少为6位&quot;, trigger: &quot;blur&quot; &#125;,  ],&#125;;const handleValidateButtonClick = (e) =&gt; &#123;  e.preventDefault();  formRef.value?.validate((errors) =&gt; &#123;    if (!errors) &#123;      message.success(&quot;验证成功&quot;);    &#125; else &#123;      console.log(errors);      message.error(&quot;验证失败&quot;);    &#125;  &#125;);&#125;;&lt;/script&gt;\n\n这里直接通过formRef.value?.validate来对所有的表单项进行表单规则验证。\n阻止默认事件这里面e.preventDefault();的含义是阻止事件的默认行为。\n详细解释\n\n事件默认行为\n\n\n表单提交：当用户点击表单的提交按钮时，浏览器会默认将表单数据发送到服务器。这个默认行为可能会导致页面重新加载。\n链接点击：当用户点击一个链接时，浏览器会默认导航到链接指定的 URL，导致页面跳转。\n输入框聚焦：当用户点击一个输入框时，浏览器会默认将光标聚焦到输入框中。\n\n\ne.preventDefault() 的作用\n\n\n阻止表单提交：在表单提交事件中使用 e.preventDefault() 可以阻止表单数据发送到服务器，从而防止页面重新加载。这在使用 AJAX 或其他前端框架（如 Vue、React）进行异步表单处理时非常有用。\n阻止链接跳转：在链接点击事件中使用 e.preventDefault() 可以阻止浏览器导航到链接指定的 URL，从而防止页面跳转。这在使用单页应用（SPA）时非常有用，可以实现页面内导航而不重新加载页面。\n阻止其他默认行为：在其他事件中，e.preventDefault() 也可以用于阻止默认行为，例如阻止输入框的默认聚焦行为。\n\n表单内置的验证规则在表单验证中，通常有多种内置的验证规则可以使用。这些规则可以帮助你确保用户输入的数据符合特定的要求。以下是一些常见的验证规则及其用途：\n\nrequired\n\n用途：确保字段不为空。\n1&#123; required: true, message: &quot;请输入节点名称&quot;, trigger: &quot;blur&quot; &#125;\n\n\nmin 和 max\n\n用途：确保字段的长度在指定的范围内。\n1&#123; min: 2, max: 20, message: &quot;长度在 2 到 20 个字符&quot;, trigger: &quot;blur&quot; &#125;\n\n\nminLength 和 maxLength\n\n用途：确保字段的长度至少为 minLength，最多为 maxLength。\n12&#123; minLength: 2, message: &quot;长度至少为 2 个字符&quot;, trigger: &quot;blur&quot; &#125;&#123; maxLength: 20, message: &quot;长度最多为 20 个字符&quot;, trigger: &quot;blur&quot; &#125;\n\n\npattern用途：确保字段的值匹配指定的正则表达式。\n\n1&#123; pattern: /^[a-zA-Z0-9]+$/, message: &quot;只能输入字母和数字&quot;, trigger: &quot;blur&quot; &#125;\n\n\nemail\n\n用途：确保字段的值是一个有效的电子邮件地址。\n1&#123; email: true, message: &quot;请输入有效的电子邮件地址&quot;, trigger: &quot;blur&quot; &#125;\n\n\ntype\n\n用途：确保字段的值是特定的类型，如 string、number、array 等。\n12&#123; type: &#x27;string&#x27;, message: &quot;请输入字符串&quot;, trigger: &quot;blur&quot; &#125;&#123; type: &#x27;number&#x27;, message: &quot;请输入数字&quot;, trigger: &quot;blur&quot; &#125;\n\n\nenum\n\n用途：确保字段的值在指定的枚举值中。\n1&#123; enum: [&#x27;admin&#x27;, &#x27;user&#x27;, &#x27;guest&#x27;], message: &quot;请输入有效的用户角色&quot;, trigger: &quot;blur&quot; &#125;\n\n自定义表单规则1234567891011121314151617181920212223242526272829303132&lt;template&gt;  &lt;form&gt;    &lt;input type=&quot;password&quot; v-model=&quot;form.password&quot; :rules=&quot;passwordRules&quot; /&gt;  &lt;/form&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      form: &#123;        password: &quot;&quot;,      &#125;,      passwordRules: [        &#123; required: true, message: &quot;请输入密码&quot;, trigger: &quot;blur&quot; &#125;,        &#123; validator: validatePassword, trigger: &quot;blur&quot; &#125;,      ],    &#125;;  &#125;,  methods: &#123;    validatePassword(rule, value, callback) &#123;      if (value === &quot;&quot;) &#123;        callback(new Error(&quot;请输入密码&quot;));      &#125; else if (value.length &lt; 6) &#123;        callback(new Error(&quot;密码至少6位&quot;));      &#125; else &#123;        callback();      &#125;    &#125;,  &#125;,&#125;;&lt;/script&gt;\n","slug":"2025-07-19-04","date":"2025-07-19T14:47:17.000Z","categories_index":"Vue.js","tags_index":"Vue.js 表单","author_index":"Reverse"},{"id":"3dc5e75cb441af920dcb5c3ab992895f","title":"关联数组的声明和使用","content":"在 Vue 中12345678const IterateState = (row) =&gt; &#123;  const state = &#123;    1: &quot;Success&quot;,    2: &quot;Warning&quot;,    3: &quot;Error&quot;,  &#125;;  return state[row] || &quot;Unknown&quot;; // 如果 row 不在对象中，返回 &quot;Unknown&quot;&#125;;\n\n在 Shell 中1234567891011121314151617181920# 声明一个关联数组declare -A _cfg# 给数组赋值_cfg[&quot;sleep&quot;]=&quot;this is sleep&quot;_cfg[&quot;data&quot;]=&quot;this is data&quot;_cfg[&quot;name&quot;]=&quot;this is name&quot;_cfg[&quot;type&quot;]=&quot;this is type&quot;# 输出数组的值echo &quot;$&#123;_cfg[&quot;sleep&quot;]&#125;&quot;echo &quot;$&#123;_cfg[&quot;data&quot;]&#125;&quot;echo &quot;$&#123;_cfg[&quot;name&quot;]&#125;&quot;echo &quot;$&#123;_cfg[&quot;type&quot;]&#125;&quot;# 输出所有键echo &quot;$&#123;!_cfg[@]&#125;&quot;# 输出所有值echo &quot;$&#123;_cfg[@]&#125;&quot;\n\n在 Go 中123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123;    var cfg = map[string]string&#123;        &quot;sleep&quot;: &quot;this is sleep&quot;,        &quot;data&quot;: &quot;this is data&quot;,        &quot;name&quot;: &quot;this is name&quot;,        &quot;type&quot;: &quot;this is type&quot;,    &#125;    // 输出数组的值    fmt.Println(cfg[&quot;sleep&quot;])    fmt.Println(cfg[&quot;data&quot;])    fmt.Println(cfg[&quot;name&quot;])    fmt.Println(cfg[&quot;type&quot;])&#125;\n","slug":"2025-07-19-03","date":"2025-07-19T14:39:17.000Z","categories_index":"关联数组","tags_index":"关联数组 Shell Go Vue.js","author_index":"Reverse"},{"id":"11dfc50955afa32461ac370ac3e78a2c","title":"Docker守护进程连接错误","content":"问题描述在使用 docker 时，发现 docker 守护进程出现连接错误，如下：\n123[root@localhost ~]# docker restart -t1 tools-nginx-1Error response from daemon: Cannot restart container tools-nginx-1: connection error: desc = &quot;transport: Error while dialing: dial unix /run/containerd/containerd.sock: connect: connection refused&quot;: unavailable[root@localhost ~]#\n\n尝试解决先检查了一下containerd的状态，看了下是异常了，目前退出代码为2(status&#x3D;2)\n12345678910111213[root@localhost ~]# systemctl status containerd● containerd.service - containerd container runtime   Loaded: loaded (/usr/local/lib/systemd/system/containerd.service; disabled; vendor preset: disabled)   Active: activating (auto-restart) (Result: exit-code) since Sun 2024-12-22 18:36:42 CST; 3s ago     Docs: https://containerd.io  Process: 48729 ExecStart=/usr/local/bin/containerd (code=exited, status=2)  Process: 48727 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS) Main PID: 48729 (code=exited, status=2)Dec 22 18:36:42 localhost systemd[1]: containerd.service: main process exited, code=exited, status=2/INVALIDARGUMENTDec 22 18:36:42 localhost systemd[1]: Unit containerd.service entered failed state.Dec 22 18:36:42 localhost systemd[1]: containerd.service failed.[root@localhost ~]#\n\n尝试重启一下containerd服务：\n123456789101112131415161718[root@localhost ~]# systemctl restart containerd[root@localhost ~]# systemctl status containerd● containerd.service - containerd container runtime   Loaded: loaded (/usr/local/lib/systemd/system/containerd.service; disabled; vendor preset: disabled)   Active: activating (auto-restart) (Result: exit-code) since Sun 2024-12-22 18:37:32 CST; 1s ago     Docs: https://containerd.io  Process: 49241 ExecStart=/usr/local/bin/containerd (code=exited, status=2)  Process: 49239 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS) Main PID: 49241 (code=exited, status=2)Dec 22 18:37:32 localhost containerd[49241]: github.com/containerd/containerd/gc/scheduler.(*gcScheduler).run(0xc00078ec00, 0x5636f1cb28b0, 0xc000040038)Dec 22 18:37:32 localhost containerd[49241]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/g...0 +0x4bfDec 22 18:37:32 localhost containerd[49241]: created by github.com/containerd/containerd/gc/scheduler.init.0.func1Dec 22 18:37:32 localhost containerd[49241]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/g...2 +0x445Dec 22 18:37:32 localhost systemd[1]: Unit containerd.service entered failed state.Dec 22 18:37:32 localhost systemd[1]: containerd.service failed.Hint: Some lines were ellipsized, use -l to show in full.[root@localhost ~]#\n\n但是并没有卵用，还是没起来，尝试下其他办法，查看错误日志，如下：\n1journalctl -u containerd -n 50 --no-pager\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- Logs begin at Sun 2024-12-22 17:12:15 CST, end at Sun 2024-12-22 18:40:57 CST. --Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.241193631+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.runtime.v1.linux\\&quot;...&quot; type=io.containerd.runtime.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.241259832+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.runtime.v2.task\\&quot;...&quot; type=io.containerd.runtime.v2Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.241334756+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.monitor.v1.cgroups\\&quot;...&quot; type=io.containerd.monitor.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242006839+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.service.v1.tasks-service\\&quot;...&quot; type=io.containerd.service.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242068886+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.internal.v1.restart\\&quot;...&quot; type=io.containerd.internal.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242163233+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.containers\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242191794+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.content\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242212102+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.diff\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242231735+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.events\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242253326+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.healthcheck\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242273932+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.images\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242296738+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.leases\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242321583+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.namespaces\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242340220+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.internal.v1.opt\\&quot;...&quot; type=io.containerd.internal.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242390209+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.snapshots\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242431370+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.tasks\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242456434+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.version\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242489898+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.introspection\\&quot;...&quot; type=io.containerd.grpc.v1Dec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242827737+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock.ttrpcDec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.242932534+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sockDec 22 18:40:57 localhost containerd[50977]: time=&quot;2024-12-22T18:40:57.243027297+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.043640s&quot;Dec 22 18:40:57 localhost containerd[50977]: panic: invalid page type: 2: 10 // [!code highlight]Dec 22 18:40:57 localhost containerd[50977]: goroutine 114 [running]:Dec 22 18:40:57 localhost containerd[50977]: go.etcd.io/bbolt.(*Cursor).search(0xc00026b080, 0x561b6f733918, 0x6, 0x6, 0x2)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/vendor/go.etcd.io/bbolt/cursor.go:250 +0x345Dec 22 18:40:57 localhost containerd[50977]: go.etcd.io/bbolt.(*Cursor).seek(0xc00026b080, 0x561b6f733918, 0x6, 0x6, 0xc00033c200, 0x4, 0x4, 0x7fd8a035d034, 0x10, 0x10, ...)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/vendor/go.etcd.io/bbolt/cursor.go:159 +0x7fDec 22 18:40:57 localhost containerd[50977]: go.etcd.io/bbolt.(*Bucket).Bucket(0xc00033c200, 0x561b6f733918, 0x6, 0x6, 0xc00033c200)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/vendor/go.etcd.io/bbolt/bucket.go:105 +0xdaDec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/metadata.scanRoots.func2(0x7fd8a035d030, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x561b6d685131)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/metadata/gc.go:101 +0xf1Dec 22 18:40:57 localhost containerd[50977]: go.etcd.io/bbolt.(*Bucket).ForEach(0xc00033c180, 0xc00026b6e8, 0x6, 0x6)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/vendor/go.etcd.io/bbolt/bucket.go:390 +0x104Dec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/metadata.scanRoots(0x561b6edc8878, 0xc00033c000, 0xc00043c000, 0xc00013c840, 0xc0005ac000, 0x0)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/metadata/gc.go:94 +0x875Dec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/metadata.(*DB).getMarked.func1(0xc00043c000, 0x0, 0x0)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/metadata/db.go:384 +0x16eDec 22 18:40:57 localhost containerd[50977]: go.etcd.io/bbolt.(*DB).View(0xc00020e400, 0xc0001d2890, 0x0, 0x0)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/vendor/go.etcd.io/bbolt/db.go:725 +0x93Dec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/metadata.(*DB).getMarked(0xc0003170a0, 0x561b6edc88b0, 0xc000040038, 0x203000, 0x203000, 0x0)Dec 22 18:40:57 localhost systemd[1]: containerd.service: main process exited, code=exited, status=2/INVALIDARGUMENTDec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/metadata/db.go:367 +0x7eDec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/metadata.(*DB).GarbageCollect(0xc0003170a0, 0x561b6edc88b0, 0xc000040038, 0x0, 0x3, 0x1, 0x2)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/metadata/db.go:284 +0xa5Dec 22 18:40:57 localhost containerd[50977]: github.com/containerd/containerd/gc/scheduler.(*gcScheduler).run(0xc000131020, 0x561b6edc88b0, 0xc000040038)Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/gc/scheduler/scheduler.go:310 +0x4bfDec 22 18:40:57 localhost containerd[50977]: created by github.com/containerd/containerd/gc/scheduler.init.0.func1Dec 22 18:40:57 localhost containerd[50977]: /home/runner/work/containerd-nightlies/containerd-nightlies/src/github.com/containerd/containerd/gc/scheduler/scheduler.go:132 +0x445Dec 22 18:40:57 localhost systemd[1]: Unit containerd.service entered failed state.Dec 22 18:40:57 localhost systemd[1]: containerd.service failed.You have mail in /var/spool/mail/root\n\n确定故障原因上面看到有一个错误，panic: invalid page type: 2: 10应该是由于数据库文件损坏导致的。\n那么可以尝试一下删除数据库文件并且重建后再启动containerd试试。\n\n\n\n\n\n\n\nWARNING\n请注意，删除之前建议先做个备份\n\n1cp -r /var/lib/containerd /var/lib/containerd.bak\n\n然后直接删除数据库文件：\n1rm -rf /var/lib/containerd/*\n\n然后我们重启下containerd服务：\n1systemctl restart containerd\n\n重启完成后，再查看一下containerd服务状态：\n123456789101112131415161718192021222324[root@localhost ~]# systemctl status containerd● containerd.service - containerd container runtime   Loaded: loaded (/usr/local/lib/systemd/system/containerd.service; disabled; vendor preset: disabled)   Active: active (running) since Sun 2024-12-22 18:47:08 CST; 4s ago     Docs: https://containerd.io  Process: 54168 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS) Main PID: 54172 (containerd)    Tasks: 22   Memory: 25.0M   CGroup: /system.slice/containerd.service           └─54172 /usr/local/bin/containerdDec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314169308+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314183237+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314197462+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.internal...ernal.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314239313+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314260981+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314276778+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314292198+08:00&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.....grpc.v1Dec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314520493+08:00&quot; level=info msg=serving... address=/run/containerd/conta...ck.ttrpcDec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314560935+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sockDec 22 18:47:08 localhost containerd[54172]: time=&quot;2024-12-22T18:47:08.314621503+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.039119s&quot;Hint: Some lines were ellipsized, use -l to show in full.[root@localhost ~]#\n\n可以看到containerd服务已经正常启动了。\n验证解决方案我们再试试重启容器：\n123456[root@localhost ~]# docker restart -t1 tools-nginx-1tools-nginx-1[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS                                    PORTS     NAMES0b68949ab785   xxxxxxxxxxxxxx   &quot;tini -- sh -c &#x27;bash…&quot;   11 minutes ago   Up 8 seconds                                        tools-nginx-1[root@localhost ~]# docker ps -a\n\n可以看到容器已经重启成功，那么至此 containerd 服务异常的问题就解决了，得出结论，数据库文件损坏导致的containerd服务异常，可以尝试删除数据库文件，重建后再启动containerd服务。\n","slug":"2025-07-19-02","date":"2025-07-19T14:34:01.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Reverse"},{"id":"4cbb08f3981d46e2c18366238303babb","title":"Categref心跳报错","content":"描述之前在工作中碰到的问题，在容器环境中运行夜莺的categref采集器会出现心跳失败的情况，如下：\n123456789101112131415161718192021222324252627282930313233343536373839root@localhost:/apps/data# /usr/local/bin/categraf --configs /apps/data/.gitrce/categraf/conf2024/12/10 22:06:57 main.go:149: I! runner.binarydir: /usr/local/bin2024/12/10 22:06:57 main.go:150: I! runner.hostname: localhost.localdomain2024/12/10 22:06:57 main.go:151: I! runner.fd_limits: (soft=1048576, hard=1048576)2024/12/10 22:06:57 main.go:152: I! runner.vm_limits: (soft=unlimited, hard=unlimited)2024/12/10 22:06:57 provider_manager.go:60: I! use input provider: [local]2024/12/10 22:06:57 prometheus_agent.go:19: I! prometheus scraping disabled!2024/12/10 22:06:57 ibex_agent.go:19: I! ibex agent disabled!2024/12/10 22:06:57 agent.go:38: I! agent starting2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.cpu started2024/12/10 22:06:57 diskio.go:64: E! failed to get disk io: open /hostfs/proc/diskstats: no such file or directory2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.diskio started2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.ipmi started2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.mem started2024/12/10 22:06:57 net.go:65: E! failed to get net io metrics: open /hostfs/proc/net/dev: no such file or directory2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.net started2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.netstat started2024/12/10 22:06:57 netstat.go:69: E! failed to read sockstat /hostfs/proc/net/sockstat open /hostfs/proc/net/sockstat: no such file or directory2024/12/10 22:06:57 diskstats_common.go:99: I! Parsing flag --collector.diskstats.device-exclude flag ^(z?ram|loop|fd|(h|s|v|xv)d[a-z]|nvme\\d+n\\d+p)\\d+$2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.node_exporter started2024/12/10 22:06:57 collector.go:189: I! collector succeeded name filenotify duration_seconds 0.0001307812024/12/10 22:06:57 collector.go:189: I! collector succeeded name netdev duration_seconds 0.0009653172024/12/10 22:06:57 collector.go:189: I! collector succeeded name diskstats duration_seconds 0.0013399312024/12/10 22:06:57 collector.go:189: I! collector succeeded name netstat duration_seconds 0.0014830272024/12/10 22:06:57 metrics_agent.go:319: I! input: local.smart started2024/12/10 22:06:57 metrics_agent.go:319: I! input: local.system started2024/12/10 22:06:57 system.go:46: E! failed to gather cpu number: open /hostfs/proc/stat: no such file or directory2024/12/10 22:06:57 agent.go:46: I! [*agent.MetricsAgent] started2024/12/10 22:06:57 agent.go:49: I! agent started2024/12/10 22:07:00 heartbeat.go:150: E! failed to marshal heartbeat request: json: unsupported value: NaN // [!code error]^C2024/12/10 22:07:01 main.go:131: I! received signal: interrupt2024/12/10 22:07:01 agent.go:53: I! agent stopping2024/12/10 22:07:01 agent.go:61: I! [*agent.MetricsAgent] stopped2024/12/10 22:07:01 agent.go:64: I! agent stopped2024/12/10 22:07:01 main.go:144: I! exitedroot@localhost:/apps/data#\n\n\n在这里出现了一个NaN的报错，然后我在 GitHub 上提交了一个issue，并且得到了解决方案\n解决方案有位大佬提供了两个解决方案，我大概看了下，应该是我启动容器时的env环境的问题\n\n按照大佬所说的，我在容器启动配置中将HOST_PROC这个参数删掉了，然后重建容器，再次查看，心跳正常，问题成功解决！\n12345678910111213141516171819202122&#123;    cat &gt;$_compose_file &lt;&lt;EOFservices:  master:    container_name: $_container_name    image: $_image2    restart: always    network_mode: host    ipc: host    uts: host    privileged: true    security_opt:      - apparmor:unconfined    environment:      - TINI_SUBREAPER=1      - GIT_REMOTE_REPO=$_gre_remote_repo      - APPS_DATA=$_apps_data      - CONTAINER_NAME=$_container_name      - HOST_PROC=/hostfs/proc // [!code --]      - HOST_MOUNT_PREFIX=/hostfsEOF&#125;\n","slug":"2025-07-19-01","date":"2025-07-19T14:28:14.000Z","categories_index":"疑难杂症","tags_index":"Categref 夜莺","author_index":"Reverse"},{"id":"f6aaa4eee62482b760c88d2f20c35498","title":"PCL2下载","content":"下载地址抗揍云下载地址: https://ltcat.lanzouv.com/b0aj6gsid\n提取码: pcl2\n","slug":"2025-07-18-16","date":"2025-07-18T17:59:06.000Z","categories_index":"Minecraft","tags_index":"PCL2 Minecraft","author_index":"Reverse"},{"id":"801add81576d2589d371217217c13cbc","title":"在Ubuntu下安装sysbox","content":"旧版本应该存在一些问题,某些场景下 docker 的功能不兼容或者不可用,在 dind 中更明显,所以直接安装最高版本.\n1234567# 这里需要把容器先全部删除,注意下,如果有重要数据得备份好docker rm $(docker ps -a -q) -f# 开始下载安装wget https://downloads.nestybox.com/sysbox/releases/v0.6.7/sysbox-ce_0.6.7-0.linux_amd64.debapt -y install ./sysbox-ce_0.6.7-0.linux_amd64.debsystemctl restart sysboxsystemctl enable sysbox\n","slug":"2025-07-18-15","date":"2025-07-18T17:54:02.000Z","categories_index":"运维","tags_index":"sysbox","author_index":"Reverse"},{"id":"909dff6351843daec939baa1f9ed28aa","title":"在Ubuntu下部署ikuai软路由","content":"概述ikuai 提供的是一个系统镜像,所以需要用到 kvm 来运行他,这里记录一下我的部署过程\n准备环境安装 kvm,这一步是必须的\n12345678910111213#!/usr/bin/env bash&#123;  apt update  apt install -y qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager  lsmod | grep kvm  usermod -aG libvirt $(whoami)  usermod -aG kvm $(whoami)  newgrp libvirt  systemctl enable libvirtd  systemctl start libvirtd  systemctl status libvirtd&#125;\n\n宿主机配置网络宿主机至少需要有一个口可以用来上网,因为 ikuai 需要两个网口,一个 wan 一个 lan,wan 口用来上网,lan 口则可以作为内网网关.\n这里直接使用网桥来创建就行,写一个配置文件,将下面的配置写进去,其实这个是自己随便定的,你可以是 172 段的 IP,内网无所谓,随便定义,看自己喜欢.\n\n\n\n\n\n\n\n\n\n地址: 192.168.9.250掩码: 16网关: 192.168.9.1\n将下面的配置写入到/etc/netplan/01-br-lan1.yaml文件中\n123456789101112131415161718network:  version: 2  renderer: networkd  ethernets:    eno1: # 改为你宿主机的网口      dhcp4: false  bridges:    br-en01:      interfaces: [eno1] # 改为你宿主机的网口      dhcp4: false      addresses:        - 192.168.9.250/16 # 随便分配个地址      gateway4: 192.168.9.1 # 指定网关      nameservers:        addresses:          - 223.5.5.5          - 119.29.29.29\n\n执行此命令让其生效\n1netplan apply\n\n下载 ikuai 镜像到官网 https://www.ikuai8.com/component/download 按需选择镜像并且下载到你的宿主机.\n下载完成后准备启动 kvm 虚拟机就行了,我这里下载的是 iKuai8_x64_3.7.20_Build202506041743.iso,你可以点击下载也行.\n或者通过命令下载到宿主机:\n1wget https://patch.ikuai8.com/3.x/iso/iKuai8_x64_3.7.20_Build202506041743.iso -O ikuai8_x64.iso\n\n启动 KVM 虚拟机\n\n\n\n\n\n\n特别注意\n\n如果你想直接运行这个脚本,你需要将 ikuai 镜像移动到/opt/iso/ikuai-x86.iso.\n设置创建磁盘的大小,这里默认是100G如果可以则不需要修改.\n设置内存和 CPU,根据你的实际情况来修改,如果足够懒,你也可以不修改直接运行 :)\n如果你的宿主机不具备图形界面则需要启用VNC功能,否则你没有办法连接到 ikuai 即便你使用 virsh console 进去也没法操作, 这里默认端口设置为 5900 了\n将你宿主机的物理网卡和刚才创建的虚拟网桥共享给虚拟机,详情见network参数部分.\n\n\n\n\neno1 作为 ikuai 的 wan 口,用来上网.\nbr-lan1 作为 ikuai 的 lan 口,用来作为网关.\n\n12345678910111213141516171819202122232425&#123;  _kvm_disk_path=&quot;/opt/iso/ikuai-x86.qcow2&quot;  _kvm_iso_path=&quot;/opt/iso/ikuai-x86.iso&quot;  mkdir -p &quot;$(dirname &quot;$_kvm_disk_path&quot;)&quot;  mkdir -p &quot;$(dirname &quot;$_kvm_iso_path&quot;)&quot;  # 创建磁盘  qemu-img create -f qcow2 &quot;$_kvm_disk_path&quot; 100G  # 安装虚拟机(4G内存, 10G磁盘, 4核CPU)，图形界面 + 桥接网络  virt-install \\    --name ikuai \\    --ram 4096 \\    --vcpus 4 \\    --os-type linux \\    --hvm \\    --virt-type kvm \\    --cdrom &quot;$_kvm_iso_path&quot; \\    --disk path=&quot;$_kvm_disk_path&quot;,format=qcow2,bus=virtio \\    --network bridge=eno1,model=virtio \\    --network bridge=br-lan1,model=virtio \\    --graphics vnc,listen=0.0.0.0,port=5900 \\    --noautoconsole \\    --osinfo detect=on,name=linux2020&#125;\n\n最后当你执行下面的脚本后,流程差不多就结束了,剩下的工作就很简单了,你只需要:\n\n等待系统安装完成,安装完成后虚拟机会重启,重启后手动virsh start ikuai启动虚拟机就行,如果看不到虚拟机则执行virsh list --all.\n打开 VNC 工具连接到你的 ikuai 虚拟机,手动配置一下网口就行 (很简单,图形化操作)\n注意 lan 口对应的是你宿主机的br-lan1,因此你在 ikuai 配置 lan 口时的地址和掩码以及网关都需要注意一下\n\n","slug":"2025-07-18-14","date":"2025-07-18T17:25:49.000Z","categories_index":"运维","tags_index":"ikuai Ubuntu 软路由","author_index":"Reverse"},{"id":"2a7ed2ed5e24b574ac1497b2e3f1a5af","title":"使用Vue实现瀑布流布局","content":"概述瀑布流布局相比栅格网格不同的就是，只要卡片塞的合理，一般是不会出现空格。\n不像栅格，只能做水平对齐，但是如果卡片的高度不能统一，那就会出现很多空白的区域，影响美观。\n安装包vue 里面vue-masonry-wall就是用来做瀑布样式的，可以直接安装引入。\n\n\n\n\n\n\n\n\n\n安装之前先注意，如果你是vue2版本的话可能是要用npm install vue-masonry-wall这个。\n下面这个是vue3的安装，实际上我测试过在vue3里面直接执行pnpm install vue-masonry-wall，并且使用。\n会出现API 兼容性问题，导致出现错误，所以我猜测这两个应该是分为 vue3 和 vue2 两个版本使用的。\n123yarn add @yeger/vue-masonry-wallnpm install @yeger/vue-masonry-wall\n\n示例代码全局引入123456import &#123; createApp &#125; from &quot;vue&quot;;import MasonryWall from &quot;@yeger/vue-masonry-wall&quot;;const app = createApp();app.use(MasonryWall);\n\n组件内使用\n\n\n\n\n\n\n建议\n值得注意的是当数据量比较大时渲染压力会增加,建议做分页来缓解前端的渲染压力\n\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt;  &lt;masonry-wall :items=&quot;items&quot; :column-width=&quot;300&quot; :gap=&quot;16&quot;&gt;    &lt;template #default=&quot;&#123; item &#125;&quot;&gt;      &lt;div class=&quot;item&quot;&gt;        &lt;img :src=&quot;item.image&quot; :alt=&quot;item.title&quot; /&gt;        &lt;h3&gt;&#123;&#123; item.title &#125;&#125;&lt;/h3&gt;        &lt;p&gt;&#123;&#123; item.description &#125;&#125;&lt;/p&gt;      &lt;/div&gt;    &lt;/template&gt;  &lt;/masonry-wall&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const items = ref([  &#123;    id: 1,    title: &quot;标题1&quot;,    description: &quot;描述1&quot;,    image: &quot;图片地址1&quot;,  &#125;,  // ... 更多数据]);&lt;/script&gt;&lt;style scoped&gt;.item &#123;  background: #fff;  border-radius: 8px;  padding: 16px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#125;.item img &#123;  width: 100%;  height: auto;  border-radius: 4px;&#125;&lt;/style&gt;\n\n配置选项masonry-wall 组件支持以下主要配置：\n\nitems: 数组，必需，要显示的数据项\ncolumn-width: 数字，每列的宽度（像素）\ngap: 数字，列之间的间距（像素）\nrtl: 布尔值，是否从右到左布局\nssr-columns: 数字，服务器端渲染时的列数\n\n响应式处理为了在不同屏幕尺寸下获得最佳显示效果，可以使用计算属性动态设置列宽：\n12345678910&lt;script setup&gt;import &#123; computed &#125; from &quot;vue&quot;;const columnWidth = computed(() =&gt; &#123;  const screenWidth = window.innerWidth;  if (screenWidth &lt; 600) return 150;  if (screenWidth &lt; 900) return 200;  return 300;&#125;);&lt;/script&gt;\n","slug":"2025-07-18-13","date":"2025-07-18T15:06:23.000Z","categories_index":"Vue.js","tags_index":"Vue.js","author_index":"Reverse"},{"id":"e7e13627a554d1367d86ca0e77896cef","title":"Wails中Go结构或方法无法映射到前端","content":"概述最近发现一个奇怪的问题，我执行wails dev时突然发现我在app.go中暴露给前端的函数居然没能自动绑定到前端的wailsjs/go/apps/xxx下。\n经过一段时间排查发现是 go 语言导出函数的返回值带有复杂类型，就是time.Time这个类型导致的，原因很简单。\n执行命令尝试手动让他去绑定：\n1wails generate module\n\n然后出现了错误\n12345678╭─hyhacct@hyhacctdeMacBook-Air ~/workspace/PeachDRAC/PeachDRAC ‹main●›╰─$ wails generate module                                                                                                                  1 ↵2025/04/24 13:24:14 KnownStructs: model.TablePass       model.WailsCommunicateNot found: time.TimeKnownStructs: model.TablePass   model.WailsCommunicateNot found: time.Time ♥   If Wails is useful to you or your company, please consider sponsoring the project:\n\n这里就是在说 wails 其实并不支持time.Time这个类型，但是恰好我暴露的函数中，有一个返回值是结构体，结构体里面有个值类型就是time.Time。\n然后这个问题就顺其而然的产生了…\n解决办法直接在对应的结构体这个类型下，给他添加一个映射: ts_type:&quot;string&quot;\n意思就是告诉 Wails 将 time.Time 序列化为字符串，不将他作为一个特殊类型处理，其实就可以了。\n具体示例：(在对应的特殊类型后面添加ts_type映射)\n12345678910type TablePass struct &#123;\tID        int       `gorm:&quot;primary_key&quot; json:&quot;id&quot;`\tUsername  string    `gorm:&quot;not null&quot; json:&quot;username&quot;`\tPassword  string    `gorm:&quot;not null&quot; json:&quot;password&quot;`\tPort      string    `gorm:&quot;not null&quot; json:&quot;port&quot;`\tStatus    bool      `gorm:&quot;not null&quot; json:&quot;status&quot;`   // 是否启用\tPriority  int       `gorm:&quot;not null&quot; json:&quot;priority&quot;` // 优先级,数字越大越高\tCreatedAt time.Time `gorm:&quot;autoCreateTime&quot; json:&quot;created_at&quot; ts_type:&quot;string&quot;`\tUpdatedAt time.Time `gorm:&quot;autoUpdateTime&quot; json:&quot;updated_at&quot; ts_type:&quot;string&quot;`&#125;\n\n然后执行自动绑定，发现没有任何错误，OK，问题顺利解决。\n123456╭─hyhacct@hyhacctdeMacBook-Air ~/workspace/PeachDRAC/PeachDRAC ‹main●›╰─$ wails generate module ♥   If Wails is useful to you or your company, please consider sponsoring the project:https://github.com/sponsors/leaanthony╭─hyhacct@hyhacctdeMacBook-Air ~/workspace/PeachDRAC/PeachDRAC ‹main●›╰─$\n","slug":"2025-07-18-12","date":"2025-07-18T15:04:34.000Z","categories_index":"Go","tags_index":"Go Wails","author_index":"Reverse"},{"id":"87e97009ba513578bced279cc7705d0d","title":"强制更新Gorm零值","content":"概述在使用 Gorm 的Updates方法更新字段时，一般情况下他会忽略掉零值，例如 false、0、&quot;&quot;，这些都属于零值\n如果你有个字段叫status，类型为bool表示该记录的状态，那么当你想修改他为false时是不会成功的。\n解决方法\n\n\n\n\n\n\n注意\n小心使用哦,别改崩了\n\nGORM 默认忽略零值（如 false），直接通过Select方法指定强制更新字段，即便你这个字段将被修改为零值。\n1234func (TablePass) AddOrUpdate(config TablePass) error &#123;    return farmework.ModuleOrm.Where(&quot;id = ?&quot;, config.ID).        Assign(config).Select(&quot;status&quot;).FirstOrCreate(&amp;config).Error&#125;\n","slug":"2025-07-18-11","date":"2025-07-18T14:59:24.000Z","categories_index":"Go","tags_index":"Go Gorm","author_index":"Reverse"},{"id":"f51d2d839d5d520af441020c6868a0d3","title":"Vue脚手架模板","content":"\n\n\n\n\n\n有啥用?\n浅浅记录一下在使用 Vue 的轮子时,各个支持库的模板,方便在新起项目时可以快速 CV 上去 :)\n\nRouter Template\n\n\n\n\n\n\n\n\n这是路由组件的 ts 代码模板,可以直接 CV 到/src/router/index.ts使用,删除一些自己不需要的东西就行.\n\n点我查看代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#123; createRouter, createWebHashHistory, RouteRecordRaw &#125; from &quot;vue-router&quot;;import &#123; useUserStore &#125; from &quot;@/stores/user&quot;; // 若使用 Piniaimport &#123; ElMessage &#125; from &quot;element-plus&quot;; // 可换成任意 UI 库import NProgress from &quot;nprogress&quot;; // 替代 loadingBar// 页面组件引入import ViewLogin from &quot;@/views/Login.vue&quot;;import ViewHome from &quot;@/views/Home.vue&quot;;import View404 from &quot;@/views/404.vue&quot;;// 路由配置const routes: RouteRecordRaw[] = [  &#123;    path: &quot;/&quot;,    redirect: &quot;/home&quot;,  &#125;,  &#123;    path: &quot;/login&quot;,    name: &quot;Login&quot;,    component: ViewLogin,    meta: &#123; public: true &#125;,  &#125;,  &#123;    path: &quot;/home&quot;,    name: &quot;Home&quot;,    component: ViewHome,    meta: &#123; requiresAuth: true &#125;,  &#125;,  &#123;    path: &quot;/:pathMatch(.*)*&quot;,    name: &quot;NotFound&quot;,    component: View404,    meta: &#123; public: true &#125;,  &#125;,];const router = createRouter(&#123;  history: createWebHashHistory(),  routes,&#125;);// 路由守卫router.beforeEach((to, from, next) =&gt; &#123;  NProgress.start();  const userStore = useUserStore();  const isAuthenticated = !!userStore.token;  if (to.meta.requiresAuth &amp;&amp; !isAuthenticated) &#123;    ElMessage.warning(&quot;请先登录&quot;);    return next(&#123; name: &quot;Login&quot; &#125;);  &#125;  if (to.path === &quot;/login&quot; &amp;&amp; isAuthenticated) &#123;    return next(&#123; name: &quot;Home&quot; &#125;);  &#125;  next();&#125;);router.afterEach(() =&gt; &#123;  NProgress.done();&#125;);export default router;\n\n\n\nPinia [TypeScript] Template\n\n\n\n\n\n\n\n\n这是 pinia 状态管理插件的 TS 模板,一般是放在/src/stores/xxxx.ts的\n\n点我查看代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; defineStore &#125; from &quot;pinia&quot;;interface UserInfo &#123;  id: string;  name: string;  email?: string;  [key: string]: any;&#125;export const useUserStore = defineStore(&quot;user&quot;, &#123;  state: (): &#123;    token: string;    userInfo: UserInfo | null;  &#125; =&gt; (&#123;    token: &quot;&quot;,    userInfo: null,  &#125;),  getters: &#123;    isLogin: (state) =&gt; !!state.token,    username: (state) =&gt; state.userInfo?.name || &quot;&quot;,  &#125;,  actions: &#123;    setToken(token: string) &#123;      this.token = token;    &#125;,    setUserInfo(info: UserInfo) &#123;      this.userInfo = info;    &#125;,    logout() &#123;      this.token = &quot;&quot;;      this.userInfo = null;    &#125;,  &#125;,  // 持久化（可选，需要配合 pinia-plugin-persistedstate 插件）  persist: &#123;    key: &quot;user-store&quot;,    paths: [&quot;token&quot;, &quot;userInfo&quot;],    storage: sessionStorage,  &#125;,&#125;);\n\n\n\nPinia [JavaScript] Template\n\n\n\n\n\n\n\n\n这是 pinia 状态管理插件的 JS 模板,一般是放在/src/stores/xxxx.js的\n\n点我查看代码\n1234567891011121314151617181920212223242526272829303132333435import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore = defineStore(&quot;user&quot;, &#123;  state: () =&gt; (&#123;    token: &quot;&quot;,    userInfo: null,  &#125;),  getters: &#123;    isLogin: (state) =&gt; !!state.token,    username: (state) =&gt; state.userInfo?.name || &quot;&quot;,  &#125;,  actions: &#123;    setToken(token) &#123;      this.token = token;    &#125;,    setUserInfo(info) &#123;      this.userInfo = info;    &#125;,    logout() &#123;      this.token = &quot;&quot;;      this.userInfo = null;    &#125;,  &#125;,  // 开启持久化（需要 pinia-plugin-persistedstate 插件）  persist: &#123;    key: &quot;user-store&quot;,    paths: [&quot;token&quot;, &quot;userInfo&quot;],    storage: sessionStorage,  &#125;,&#125;);\n\n\n\naxios 二次封装\n\n\n\n\n\n\n\n\n可以直接写到/src/api/request.ts\n\n点我查看代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; useUserStore &#125; from &quot;@/stores/user&quot;;const BASE_URL = import.meta.env.VITE_API_BASE_URL || &quot;/api&quot;;const service: AxiosInstance = axios.create(&#123;  baseURL: BASE_URL,  timeout: 10000,  headers: &#123;    &quot;Content-Type&quot;: &quot;application/json&quot;,  &#125;,&#125;);// 请求拦截器service.interceptors.request.use(  (config: AxiosRequestConfig) =&gt; &#123;    const userStore = useUserStore();    const token = userStore.token;    if (token) &#123;      config.headers = &#123;        ...config.headers,        Authorization: `Bearer $&#123;token&#125;`,      &#125;;    &#125;    return config;  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);// 响应拦截器service.interceptors.response.use(  (response: AxiosResponse) =&gt; &#123;    const &#123; data &#125; = response;    // 根据业务约定处理    if (data.code !== 0) &#123;      ElMessage.error(data.message || &quot;请求失败&quot;);      return Promise.reject(data);    &#125;    return data.data; // 默认返回 data 下的 data  &#125;,  (error) =&gt; &#123;    const status = error?.response?.status;    if (status === 401) &#123;      const userStore = useUserStore();      userStore.logout();      ElMessage.error(&quot;登录已过期，请重新登录&quot;);      // 可跳转登录页    &#125; else if (status === 500) &#123;      ElMessage.error(&quot;服务器错误&quot;);    &#125; else &#123;      ElMessage.error(error?.response?.data?.message || &quot;请求异常&quot;);    &#125;    return Promise.reject(error);  &#125;);export default service;\n\n\n\n\n\n\n\n\n\n\n怎么使用? 参考下面的代码\n123456789101112131415161718import request from &quot;@/api/request&quot;;interface LoginParams &#123;  username: string;  password: string;&#125;interface LoginResponse &#123;  token: string;  userInfo: &#123;    id: string;    name: string;  &#125;;&#125;export function login(data: LoginParams) &#123;  return request.post&lt;LoginResponse&gt;(&quot;/auth/login&quot;, data);&#125;\n\n\n\n","slug":"2025-07-18-10","date":"2025-07-18T14:40:25.000Z","categories_index":"Vue.js","tags_index":"Vue.js","author_index":"Reverse"},{"id":"412695f5eb189a644d181b95b6e4062a","title":"在Linux下创建Supervisord服务单元","content":"概述Supervisord 是一个轻量级的进程管理工具。它允许创建和管理多个进程，并提供一些高级功能，如进程监控、自动重启、日志管理等。\n他和 Systemd 一样，都是用于管理进程的工具。\n安装1apt install supervisor\n\n安装完成后有个配置文件: supervisord.conf 如果找不到的话用 find 寻找一下就行.\n然后需要启动 supervisord 服务:\n1supervisord -c /etc/supervisor/supervisord.conf\n\n\n\n\n\n\n\n\n\n\n注意下,这里的配置文件是你实际的配置文件所在路径,如果你移动过这个 conf 文件的位置,请使用实际的路径.\n进行配置和上一篇文章一样继续假设我们的应用叫 project-apps 并且需要创建一个服务单元.\n给supervisord 添加配置:\n1234567891011121314151617[supervisord]nodaemon=truelogfile=/dev/nulllogfile_maxbytes=0pidfile=/tmp/supervisord.pid[program:project-apps]command=/usr/local/bin/project-appsuser=nobodyenvironment=PATH=&quot;/usr/local/bin:/usr/bin:/bin&quot;autostart=trueautorestart=truestartsecs=10startretries=3redirect_stderr=truestdout_logfile=/dev/stdoutstderr_logfile=/dev/stderr\n\n逐项解释：\n[supervisord] 部分：\n\nnodaemon=true：以非守护进程模式运行（容器需要前台进程）。\nlogfile=/dev/null：禁用 supervisord 自身的日志文件（容器日志通过 stdout&#x2F;stderr 收集）。\nlogfile_maxbytes=0：防止日志文件增长。\npidfile=/tmp/supervisord.pid：指定 PID 文件路径。\n\n[program:project-apps] 部分：\n\ncommand=/usr/local/bin/project-apps：运行的命令，等价于 systemd 的 ExecStart。\nuser=nobody：以 nobody 用户运行，等价于 systemd 的 User&#x3D;nobody。\nenvironment=PATH=...：设置环境变量，等价于 systemd 的 Environment。\nautostart=true：supervisord 启动时自动启动 project-apps\nautorestart=true：进程退出时自动重启，等价于 systemd 的 Restart&#x3D;always。\nstartsecs=10：进程运行 10 秒后认为启动成功（避免频繁重启）。\nstartretries=3：启动失败时重试 3 次。\nredirect_stderr=true：将 stderr 重定向到 stdout。\nstdout_logfile=/dev/stdout：将 stdout 输出到容器日志。\nstderr_logfile=/dev/stderr：将 stderr 输出到容器日志。\n\n启动1supervisord -c /etc/supervisor/supervisord.conf\n\n查看状态1supervisorctl status\n\n停止1supervisorctl stop project-apps\n\n重启1supervisorctl restart project-apps\n\n支持的各个参数\n\n\n参数名\n描述\n类型\n默认值\n示例值\n与 systemd 的对应\n\n\n\ncommand\n指定要运行的命令或可执行文件路径\n字符串\n无（必填）\nproject-apps\nExecStart\n\n\nuser\n指定运行进程的用户\n字符串\n无（以 supervisord 的用户运行）\nnobody\nUser\n\n\nenvironment\n设置进程的环境变量，格式为 KEY&#x3D;”value”,KEY2&#x3D;”value2”\n字符串\n无\nPATH=&quot;/usr/local/bin:/usr/bin:/bin&quot;\nEnvironment\n\n\ndirectory\n运行命令前切换的工作目录\n字符串\n无（当前目录）\n/app\nWorkingDirectory\n\n\nautostart\n是否在 supervisord 启动时自动启动进程\n布尔值\ntrue\ntrue\nWantedBy（间接对应）\n\n\nautorestart\n进程退出时是否自动重启（true&#x2F;false&#x2F;unexpected）\n字符串\nfalse\ntrue\nRestart（always 对应 true）\n\n\nstartsecs\n进程运行多少秒后认为启动成功（用于重启判断）\n整数\n1\n10\n无直接对应（类似 RestartSec）\n\n\nstartretries\n启动失败时的最大重试次数\n整数\n3\n3\n无直接对应\n\n\nexitcodes\n视为正常退出的退出码（仅当 autorestart&#x3D;unexpected 时生效）\n逗号分隔的整数\n0\n0,2\n无直接对应\n\n\nstopwaitsecs\n停止进程时等待的秒数（超时后发送 SIGKILL）\n整数\n10\n10\nTimeoutStopSec\n\n\nstopasgroup\n是否向整个进程组发送停止信号\n布尔值\nfalse\ntrue\n无直接对应（类似 KillMode&#x3D;process-group）\n\n\nkillasgroup\n是否向整个进程组发送终止信号（SIGKILL）\n布尔值\nfalse\ntrue\n无直接对应\n\n\nstopsignal\n用于停止进程的信号\n字符串\nTERM\nINT\nKillSignal\n\n\npriority\n进程启动的优先级（数字越小优先级越高）\n整数\n999\n100\n无直接对应（类似 Nice 或启动顺序）\n\n\nnumprocs\n启动的进程实例数（多实例运行）\n整数\n1\n2\n无直接对应\n\n\nnumprocs_start\n多实例进程的起始编号（与 numprocs 配合）\n整数\n0\n1\n无直接对应\n\n\nprocess_name\n进程名称模板（用于多实例，含 % 占位符）\n字符串\n%(program_name)s\n%(program_name)s_%(process_num)02d\n无直接对应\n\n\nredirect_stderr\n是否将 stderr 重定向到 stdout\n布尔值\nfalse\ntrue\n无直接对应（日志处理相关）\n\n\nstdout_logfile\nstdout 日志输出文件路径（支持 &#x2F;dev&#x2F;stdout）\n字符串\nAUTO（自动生成日志文件）\n/dev/stdout\n无直接对应（systemd 使用 journalctl）\n\n\nstdout_logfile_maxbytes\nstdout 日志文件的最大大小\n字符串\n50MB\n10MB\n无直接对应\n\n\nstdout_logfile_backups\nstdout 日志文件的备份数量\n整数\n10\n5\n无直接对应\n\n\nstderr_logfile\nstderr 日志输出文件路径\n字符串\nAUTO\n/dev/stderr\n无直接对应\n\n\nstderr_logfile_maxbytes\nstderr 日志文件的最大大小\n字符串\n50MB\n10MB\n无直接对应\n\n\nstderr_logfile_backups\nstderr 日志文件的备份数量\n整数\n10\n5\n无直接对应\n\n\nstdout_capture_maxbytes\nstdout 捕获缓冲区大小（用于事件监听）\n字符串\n0\n1MB\n无直接对应\n\n\nstdout_events_enabled\n是否启用 stdout 事件（用于事件监听）\n布尔值\nfalse\ntrue\n无直接对应\n\n\nstderr_events_enabled\n是否启用 stderr 事件\n布尔值\nfalse\ntrue\n无直接对应\n\n\n","slug":"2025-07-18-08","date":"2025-07-18T14:16:37.000Z","categories_index":"运维","tags_index":"服务单元 Linux","author_index":"Reverse"},{"id":"cb4e47217e236130c02e8a1c94b69087","title":"在Linux下创建System服务单元","content":"概述Systemd 是 Linux 系统的一种初始化系统（init），主要负责控制系统的启动和运行，并提供了一种基于服务的管理机制。它取代了传统的 init 系统，成为现代 Linux 发行版的标准。\n这里假设我需要为我的应用创建一个名字叫project-apps.service的服务单元。\n创建服务单元12345678910111213141516171819cat &gt;/etc/systemd/system/project-apps.service &lt;&lt;EOF[Unit]Description=project-apps ServiceAfter=network.target[Service]ExecStart=/usr/local/bin/project-appsRestart=alwaysUser=nobodyGroup=nogroupEnvironment=PATH=/usr/local/bin:/usr/bin:/bin[Install]WantedBy=multi-user.targetEOFsystemctl daemon-reloadsystemctl enable project-apps.servicesystemctl restart project-apps.service\n\n\ncat &gt;: 使用 cat 命令将后续内容写入文件。\n/etc/systemd/system/project-apps.service: 指定文件路径，systemd 服务单元文件通常存放在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 目录下。\n&lt;&lt;EOF ... EOF: 使用 heredoc 语法，将多行内容写入文件，直到遇到 EOF 标记。\n\n[Unit] 部分123[Unit]Description=project-apps ServiceAfter=network.target\n\n\nDescription: 服务描述，显示为 Dcim Service，用于标识服务的用途。\nAfter=network.target: 指定服务在 network.target（网络服务）启动后再启动，确保网络可用。\n\n[Service] 部分123456[Service]ExecStart=/usr/local/bin/project-appsRestart=alwaysUser=nobodyGroup=nogroupEnvironment=PATH=/usr/local/bin:/usr/bin:/bin\n\n\nExecStart: 指定服务启动时执行的命令 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;project-apps。这意味着有一个可执行文件 project-apps 位于 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;。\nRestart=always: 如果服务因任何原因停止（例如崩溃），systemd 将自动重启服务。\nUser=nobody: 服务以 nobody 用户身份运行，这是一个低权限用户，用于提高安全性。\nGroup=nogroup: 服务以 nogroup 组身份运行，同样是为了限制权限。\nEnvironment: 设置环境变量 PATH，确保服务可以找到 &#x2F;usr&#x2F;local&#x2F;bin、&#x2F;usr&#x2F;bin 和 &#x2F;bin 目录中的可执行文件。\n\n[Install] 部分12[Install]WantedBy=multi-user.target\n\n\nWantedBy=multi-user.target: 指定服务在 multi-user.target（多用户模式，相当于系统启动到命令行环境）时启用。这是典型的非图形化服务的目标。\n\n后续操作1systemctl daemon-reload\n\n\nsystemctl daemon-reload: 通知 systemd 重新加载配置文件。因为我们刚刚创建或修改了 dcim.service 文件，此命令确保 systemd 识别新的服务定义。\n需要 sudo 权限，因为修改 systemd 配置是系统级操作。\n\n12systemctl enable project-apps.servicesystemctl restart project-apps.service\n\n\nsystemctl enable project-apps.service: 启用服务，使其在系统启动时自动启动。\nsystemctl restart project-apps.service: 重新启动服务，确保配置生效。\n\n另外，如果需要查看服务状态，可以使用以下命令：\n1systemctl status project-apps.service\n\n希望查看服务日志，可以使用以下命令：\n1journalctl -u project-apps.service\n","slug":"2025-07-18-09","date":"2025-07-18T14:16:37.000Z","categories_index":"运维","tags_index":"服务单元 Linux","author_index":"Reverse"},{"id":"5cd89c20fd6a2aad9144cf965a99cbdc","title":"利用zabbix api计算流量月95值","content":"直接提供脚本虽然这个脚本是让 AI 帮忙写的,但经过实际验证,是有效的,并且我一直在使用\n\n\n\n\n\n\n\n\n\n注意这的 1,2,3 步骤中的一些参数需要自己配置,比如时间范围,单位换算,文件路径等.\n根据你实际情况改改,另外就是一些必备软件包得装一下,比如jq bc curl什么的.\n最重要的是ITEM_ID这个变量,你需要从 zabbix 中找到你想计算 95 的流量图,然后把他的 itemid 拿出来.\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env bash# 1. Zabbix API 参数配置ZABBIX_URL=&quot;https://xxxxxxx/api_jsonrpc.php&quot; # 你的 zabbix API 地址ITEM_ID=&quot; 123456&quot; # 你的 item id,这个是流量图的 itemid,可以自己找一下AUTH_TOKEN=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; # 你的 auth token# 2. 时间范围,假设（2025-04-01 ~ 2025-04-30）TIME_FROM=1743436800 # 2025-04-01 00:00:00 转换到对应的秒级时间戳TIME_TILL=1746028799 # 2025-04-30 23:59:59 转换到对应的秒级时间戳# 3. 单位换算：字节 =&gt; MBBYTES_TO_MB=1048576JSON_PATH=&quot;/tmp/zabbix.json&quot; # zbx 请求数据CSV_PATH=&quot;/tmp/zabbix_full_data.csv&quot; # 全量数据(每 5 分钟一个点的 95 值)ROW_PATH=&quot;/tmp/zabbix_row_data.csv&quot; # 每分钟数据# 4. 获取历史数据（只下载一次）if [ ! -f &quot;$JSON_PATH&quot; ]; then  echo &quot;拉取 Zabbix 数据中...&quot;  RESPONSE=$(curl -s &quot;$ZABBIX_URL&quot; \\    -H &quot;Content-Type: application/json&quot; \\    --data-raw &quot;&#123;    \\&quot;jsonrpc\\&quot;: \\&quot;2.0\\&quot;,    \\&quot;id\\&quot;: 1,    \\&quot;method\\&quot;: \\&quot;history.get\\&quot;,    \\&quot;params\\&quot;: &#123;      \\&quot;output\\&quot;: \\&quot;extend\\&quot;,      \\&quot;itemids\\&quot;: \\&quot;$ITEM_ID\\&quot;,      \\&quot;history\\&quot;: 3,      \\&quot;time_from\\&quot;: $TIME_FROM,      \\&quot;time_till\\&quot;: $TIME_TILL,      \\&quot;sortfield\\&quot;: [\\&quot;clock\\&quot;, \\&quot;itemid\\&quot;],      \\&quot;sortorder\\&quot;: \\&quot;ASC\\&quot;    &#125;,    \\&quot;auth\\&quot;: \\&quot;$AUTH_TOKEN\\&quot;  &#125;&quot;)  echo &quot;$RESPONSE&quot; &gt;&quot;$JSON_PATH&quot;else  RESPONSE=$(awk &#x27;NF&#x27; &quot;$JSON_PATH&quot;)fi# 5. 提取时间和流量，转换为 MB，并写入 CSV 文件echo &quot;Timestamp,Datetime,Value(MB)&quot; &gt;&quot;$CSV_PATH&quot;# 暂存 5 分钟分组后的最大值declare -A GROUPED_MAX# 从 JSON 中提取数据并分组while IFS= read -r line; do  CLOCK=$(echo &quot;$line&quot; | jq -r &#x27;.clock&#x27;)  VALUE=$(echo &quot;$line&quot; | jq -r &#x27;.value&#x27;)  VALUE_MB=$(awk -v val=&quot;$VALUE&quot; -v factor=&quot;$BYTES_TO_MB&quot; &#x27;BEGIN &#123;printf &quot;%.2f&quot;, val / factor&#125;&#x27;)  # 向下取整到 5 分钟（300 秒）粒度  GROUP_TS=$((CLOCK / 300 * 300))  # 如果该组未存在，或当前值更大，更新最大值  if [[ -z &quot;$&#123;GROUPED_MAX[$GROUP_TS]&#125;&quot; ]] || (($(echo &quot;$VALUE_MB &gt; $&#123;GROUPED_MAX[$GROUP_TS]&#125;&quot; | bc -l))); then    GROUPED_MAX[$GROUP_TS]=$VALUE_MB  fi  # 写出每分钟的数据,带可读时间  DATETIME=$(date -d &quot;@$CLOCK&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;)  echo &quot;$DATETIME,$VALUE_MB&quot; &gt;&gt;&quot;$ROW_PATH&quot;done &lt; &lt;(echo &quot;$RESPONSE&quot; | jq -c &#x27;.result | sort_by(.clock)[]&#x27;)# 提取排序后的 5 分钟粒度时间点和值，写入 CSV，并保存值用于 P95VALUES_MB=()for ts in $(printf &quot;%s\\n&quot; &quot;$&#123;!GROUPED_MAX[@]&#125;&quot; | sort -n); do  val=&quot;$&#123;GROUPED_MAX[$ts]&#125;&quot;  datetime=$(date -d &quot;@$ts&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;)  echo &quot;$ts,$datetime,$val&quot; &gt;&gt;&quot;$CSV_PATH&quot;  VALUES_MB+=(&quot;$val&quot;)done# 6. 统计与 P95 计算TOTAL=$&#123;#VALUES_MB[@]&#125;if [[ $TOTAL -lt 1 ]]; then  echo &quot;未获取到有效数据，退出。&quot;  exit 1fiSORTED=($(printf &quot;%s\\n&quot; &quot;$&#123;VALUES_MB[@]&#125;&quot; | sort -n))PERCENTILE_INDEX=$(echo &quot;$TOTAL * 0.95&quot; | bc | awk &#x27;&#123;printf(&quot;%d&quot;, ($1==int($1))?$1:$1+1)&#125;&#x27;)P95_VALUE=$&#123;SORTED[$((PERCENTILE_INDEX - 1))]&#125;# 7. 输出汇总echo &quot;✅ 数据点总数: $TOTAL&quot;echo &quot;📈 95 百分位位置: $PERCENTILE_INDEX&quot;echo &quot;📊 整体 95 值: $P95_VALUE MB&quot;echo &quot;📁 CSV 文件已生成: $CSV_PATH&quot;\n\n最终结果大概长这样:\n1234567✅ 数据点总数: 3589📈 95 百分位位置: 3410📊 整体 95 值: 1955.15 MB📁 CSV 文件已生成: /tmp/zabbix_full_data.csv\n","slug":"2025-07-18-07","date":"2025-07-18T14:12:49.000Z","categories_index":"运维","tags_index":"zabbix 月95","author_index":"Reverse"},{"id":"c59c56761bc7b0b0394e25c388e5d7f6","title":"利用nftables做端口流量统计","content":"概述通过nftables规则对特定端口范围做计数流量统计,可以借此计算瞬时流量.\n写规则假设这里我统计的是11000-19000端口范围的流量,入站和出站都统计,然后用计数器来计算流量.\n大概流程就是创一个名字叫portstats的表,然后创两个链,一个叫input_chain,一个叫output_chain,\n然后创两个计数器,一个叫input_tcp_range,一个叫output_tcp_range,然后创两个规则,一个叫input_tcp_range,一个叫output_tcp_range.\n12345678910111213141516171819202122232425262728293031# 创建表和链nft add table inet portstatsnft add chain inet portstats input_chain &#123; type filter hook input priority 0\\; &#125;nft add chain inet portstats output_chain &#123; type filter hook output priority 0\\; &#125;# 创建表nft add table inet portstats# 创建 input 链（接收进入本机的数据）nft add chain inet portstats input_chain &#123; type filter hook input priority 0\\; &#125;# 创建 output 链（从本机发出的数据）nft add chain inet portstats output_chain &#123; type filter hook output priority 0\\; &#125;# 创建计数器 TCPnft add counter inet portstats input_tcp_rangenft add counter inet portstats output_tcp_range# 创建计数器 UDPnft add counter inet portstats input_udp_rangenft add counter inet portstats output_udp_range# 入站 TCPnft add rule inet portstats input_chain tcp dport 11000-19000 counter name input_tcp_range# 入站 UDPnft add rule inet portstats input_chain udp dport 11000-19000 counter name input_udp_range# 出站 TCPnft add rule inet portstats output_chain tcp sport 11000-19000 counter name output_tcp_range# 出站 UDPnft add rule inet portstats output_chain udp sport 11000-19000 counter name output_udp_range\n\n创建完成后,可以查看这个表,能直接看到他的流量统计.\n在输出中,能看到counter的流量统计,packets是包的数量,bytes是字节数.\n\ninput_tcp_range 入站 TCP 流量统计\noutput_tcp_range 出站 TCP 流量统计\ninput_udp_range 入站 UDP 流量统计\noutput_udp_range 出站 UDP 流量统计\n\n\n\n\n\n\n\n\n\n\n当然,你可以直接通过他的 bytes 来计算计数流量,包括瞬时流量你也能记录到.\n1nft list table inet portstats\n\n1234567891011121314151617181920212223242526272829303132333435root@localhost:~# nft list table inet portstatstable inet portstats &#123;        counter input_tcp_range &#123;                packets 3646743 bytes 234844099        &#125;        counter output_tcp_range &#123;                packets 2718337 bytes 7699060368        &#125;        counter input_udp_range &#123;                packets 83 bytes 12353        &#125;        counter output_udp_range &#123;                packets 96 bytes 7375        &#125;        chain input_chain &#123;                type filter hook input priority filter; policy accept;                tcp dport 11000-19000 counter name &quot;input_tcp_range&quot;                udp dport 11000-19000 counter name &quot;input_udp_range&quot;                tcp dport 11000-19000 counter name &quot;input_tcp_range&quot;                udp dport 11000-19000 counter name &quot;input_udp_range&quot;        &#125;        chain output_chain &#123;                type filter hook output priority filter; policy accept;                tcp sport 11000-19000 counter name &quot;output_tcp_range&quot;                udp sport 11000-19000 counter name &quot;output_udp_range&quot;                tcp sport 11000-19000 counter name &quot;output_tcp_range&quot;                udp sport 11000-19000 counter name &quot;output_udp_range&quot;        &#125;&#125;root@localhost:~#\n\n流量计算比如上面的output_tcp_range当前流量在7699060368字节,如果要转换到 Mb 单位,你应该:\n1echo &#x27;scale=2; 7699060368 / 1048576&#x27; | bc\n\n单位是 Mb,这样计算出来的结果仅仅只是计数器记录的流量,并不是瞬时流量.\n17342.39\n\n计算瞬时流量原理也很简单,先获取当前计数器记录的流量,然后 sleep10 秒后,再获取一次计数器记录的流量,然后计算两次的差值.\n123nft list table inet portstatssleep 10 # 等待 10 秒再取一次nft list table inet portstats\n\n比如我这里两次执行结果的input_tcp_range.\n\n第一次 234844099\n第二次 4346338221\n那么瞬时流量计算方式直接参考以下脚本\n\n\n\n\n\n\n\n\n\n\n第二次的结果减去第一次的结果,并且除以 10 的延迟秒,得到瞬时流量(如果要到 Mb 单位则再除以 1048576).\n如果你的延迟设置的不是 10 秒,而是 60 秒,那你就得除以 60.\n1echo &#x27;scale=2; (4346338221 - 234844099) / 1048576 / 10&#x27; | bc # 单位是 Mb/s\n\n1392.10\n\n删除规则如果后续你不想要这个表或者这些规则了,可以直接删除这张表,他会将这个表下的规则,链,计数器一并清理.\n1nft delete table inet portstats\n","slug":"2025-07-18-06","date":"2025-07-18T14:10:07.000Z","categories_index":"运维","tags_index":"nftables","author_index":"Reverse"},{"id":"5861fe1ef331a2f0173b8f2c74ba7f6a","title":"为服务器启用超线程模式","content":"查看是否启用超线程如果 Thread(s) per core: 2，说明超线程已启用（每个物理核心有 2 个逻辑线程）。\n如果 Thread(s) per core: 1，说明超线程未启用。\n1lscpu | grep &quot;Thread(s) per core&quot;\n\n启用所有核心大概这样,写入 1 表示启用此核心,确保核心全部启用\n1234for CPU in /sys/devices/system/cpu/cpu[0-9]*; do  sudo bash -c &quot;echo 1 &gt; $CPU/online&quot; 2&gt;/dev/nulldonelscpu | grep &quot;Thread(s) per core&quot;\n\n启用超线程这里以 PowerEdge R730 机型为例,重启按 F2 进入 BIOS.\n然后按照下面的图片找到对应的选项并且将其启用即可\n\n进入 System BIOS 选项\n选择 Precessor Settings 选项(处理器设置)\n将 Logical Processor 设置为 Enable(启用即可)\n\n\n\n\n\n\n\n\n\n\nLogical Processor 的名字其实不一定,有时也叫 Hyper-Threading 或 Logical Processor Enable 看是什么机型\n\n\n\n验证结果保存 BIOS 配置并且退出,然后重启进入系统,再次尝试查看\n输出结果中的Thread(s) per core为 2 表示就启用了超线程\n1lscpu | grep &quot;Thread(s) per core&quot;\n\n或者\n1lscpu\n","slug":"2025-07-18-05","date":"2025-07-18T14:06:43.000Z","categories_index":"运维","tags_index":"超线程","author_index":"Reverse"},{"id":"1c2170fb6fef60f29c3c2770dcf97c19","title":"使用Go从Chroom中获取页面Cookies","content":"概述浅浅的玩一下github.com/go-rod/rod这个库.\n通过这个支持库,可以很方便的打开一个浏览器并且让他访问一个 url,在他访问 url 时你还可以监听这个 url 的 cookies.\n开始实操为了防止被检测到自动化，我这里是注入了 js 屏蔽了检测。\n\n首先使用browser.MustPage(&quot;&quot;)打开了一个空的标签页。\n注入 JS 脚本修改navigator.webdriver为false。\n注入修改完成后再打开真实的目标 URL，这样目标网站就没法通过这个值去检测我是不是自动化程序了。\n同时滑块成功后页面会自动跳转到其他地方，所以我做了一个拦截，如果不需要的话可以直接删除。\n\n\n\n\n\n\n\n\n\n\n可能要注意下，不一定所有的站点都是通过webdriver来检测自动化程序的，但是我这里只提供这个方式，至于其他的需要按照实际场景来看。\n并且我这里 go 程序只是为了获取滑块后的 cookies，如果想获取请求头或者其他东西的话，可能得自己再研究下。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport (\t&quot;context&quot;\t&quot;log/slog&quot;\t&quot;time&quot;\t&quot;github.com/go-rod/rod&quot;\t&quot;github.com/go-rod/rod/lib/launcher&quot;\t&quot;github.com/go-rod/rod/lib/proto&quot;)func main() &#123;  url := &quot;https://qq.com&quot;\tu := launcher.New().\t\tHeadless(false). // 显示窗口\t\t// 设置窗口尺寸（可选）\t\tSet(&quot;window-size&quot;, &quot;1200,800&quot;).\t\tSet(&quot;disable-blink-features&quot;, &quot;AutomationControlled&quot;).\t\tMustLaunch()\tbrowser := rod.New().ControlURL(u).MustConnect()\t// 打开页面\tpage := browser.MustPage(&quot;&quot;)\t// 在页面加载前注入 JavaScript，修改 navigator.webdriver\t_, err := page.EvalOnNewDocument(`\t\tObject.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;\t\t\tget: () =&gt; false\t\t&#125;);\t`)\tif err != nil &#123;\t\tslog.Error(&quot;在页面加载前注入 JavaScript，修改 navigator.webdriver失败&quot;, &quot;ProxyService&quot;, err)\t&#125;\t// 访问目标页面\tpage.MustNavigate(url).MustWaitLoad()\t// 拦截导航请求，禁止跳转\trouter := page.HijackRequests()\trouter.MustAdd(&quot;*&quot;, func(ctx *rod.Hijack) &#123;\t\t// 如果请求是导航（即页面跳转），阻止它\t\tif ctx.Request.Type() == proto.NetworkResourceTypeDocument &amp;&amp; ctx.Request.URL().String() != url &#123;\t\t\tslog.Info(&quot;阻止页面跳转&quot;, &quot;ProxyService&quot;, ctx.Request.URL())\t\t\tctx.Response.Fail(proto.NetworkErrorReasonAborted)\t\t\treturn\t\t&#125;\t\tctx.MustLoadResponse()\t&#125;)\tgo router.Run()\t// 等待页面稳定\t// page.MustWaitStable()\t// 验证 navigator.webdriver\t_, evalErr := page.Eval(`navigator.webdriver`)\tif evalErr != nil &#123;\t\tslog.Error(&quot;验证 navigator.webdriver失败&quot;, &quot;ProxyService&quot;, evalErr)\t&#125;\t// 获取当前页面的所有 Cookie\tfor &#123;\t\tcookies := page.MustCookies()\t\tslog.Info(&quot;自动化拦截页面cookies&quot;, &quot;ProxyService&quot;, cookies)\t\tfor _, c := range cookies &#123;\t\t\tif c.Name == &quot;demo_cookies_name&quot; &amp;&amp; c.Value != &quot;&quot; &#123;    \t\tslog.Info(&quot;已拦截到demo_cookies_name&quot;, &quot;ProxyService&quot;, c.Value)\t\t\t\ttime.Sleep(1000 * time.Millisecond) // 等待1秒\t\t\t\tbrowser.MustClose() // 关闭浏览器\t\t\t\treturn // 结束当前函数\t\t\t&#125;\t\t&#125;\t\ttime.Sleep(100 * time.Millisecond) // 控制一下获取频率\t&#125;&#125;\n","slug":"2025-07-18-04","date":"2025-07-18T13:59:31.000Z","categories_index":"Go","tags_index":"Go","author_index":"Reverse"},{"id":"b72299e78af8a95e50e0ce74a5a78e6d","title":"NaiveUI的Table表分页配置","content":"因为 NaiveUI 的 DataTable 数据表格组件支持 pagination 参数,所以我一直固定使用这个模板来作为分配配置,而不需要后端来分页\n\n\n\n\n\n\nTIP\n参考代码,在代码中,你无需关注他是怎么实现的,只需要定义好pagination对象,并且配置到数据表格组件中的 pagination 参数即可\n\n1234567891011121314151617181920212223242526272829303132333435&lt;template&gt;  &lt;n-data-table :pagination=&quot;pagination&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;const pagination = &#123;  prefix(&#123; itemCount &#125;) &#123;    return `总计 $&#123;itemCount&#125; 条数据`;  &#125;,  pageSizes: [    &#123;      label: &quot;默认10条&quot;,      value: 10,    &#125;,    &#123;      label: &quot;全部显示&quot;,      value: 9999,    &#125;,    &#123;      label: &quot;20 每页&quot;,      value: 20,    &#125;,    &#123;      label: &quot;30 每页&quot;,      value: 30,    &#125;,    &#123;      label: &quot;40 每页&quot;,      value: 40,    &#125;,  ],  showSizePicker: true,  displayOrder: [&quot;quick-jumper&quot;, &quot;pages&quot;, &quot;size-picker&quot;],&#125;;&lt;/script&gt;\n","slug":"2025-07-18-03","date":"2025-07-18T13:59:31.000Z","categories_index":"Vue.js","tags_index":"Vue.js NaiveUI","author_index":"Reverse"},{"id":"8a5374f6cc33ebcdaaad4a3c993161aa","title":"Hexo发布到GitHubPage报错404","content":"Number 1检查静态资源是否已经存在,访问地址:\nhttps://github.com/&lt;你的用户名&gt;/&lt;你的仓库&gt;/tree/&lt;静态文件分支&gt;\n如果你的工作流会将静态文件编译到指定分支的话,就有必要去看看是否编译出来了\nNumber 2进入你的 GitHub 仓库 &gt; Settings &gt; Pages &gt; Source &gt; 改为:Deploy from a branch\n并且下面的Branch分支需要改为你静态文件所在的分支,然后路径注意别错了,默认就/(root)就行\nNumber 3在 Hexo 的 _config.yml 配置文件中修改url参数,改为你实际的博客地址,比如我的\n1url: https://blog.hyhacct.com\n","slug":"2025-07-18-02","date":"2025-07-18T10:55:25.000Z","categories_index":"GitHub","tags_index":"GitHubPage","author_index":"Reverse"},{"id":"ac4f53f75d4e475cf1b29cd6d8ebee29","title":"在Github使用PAT方式跨仓库部署","content":"如果想直接用 Github Actions 的工作流自动化部署构建 Hexo 项目的话,需要编写 workflows 配置\n创建 Token首先去创建一个 Token\n\n访问 https://github.com/settings/tokens\n点击 “Fine-grained token”\n选择权限 repo （将这几个启用：contents、actions、deployments）\n有效期 随便多久都行,主要看你,我直接永久\n\n然后他会生成一个 Token,这个 Token 只显示一次,一定要先记下\n配置 Secrets接下来进入你的构建目标仓库,依次选择: Settings &gt; Secrets and variables &gt; Actions\n添加一个 secret,比如我这里变量名字叫 BLOG_TOKEN,然后值就是上面生成的 Token,填进去保存即可\n配置 workflows接着改改你的构建流程,把刚才创建的 BLOG_TOKEN 变量引用进去\n123456789101112131415161718192021222324252627282930313233343536name: Deploy Hexo to GitHub Pageson:  push:    branches:      - main # 或者是 master，根据你的默认分支修改jobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout source code        uses: actions/checkout@v4      - name: Set up Node.js        uses: actions/setup-node@v4        with:          node-version: &quot;18&quot; # 根据你的项目需要修改 Node 版本          cache: &quot;npm&quot;      - name: Install dependencies        run: |          npm install -g hexo-cli          npm install      - name: Clean and generate Hexo site        run: |          hexo clean          hexo generate      - name: Deploy to GitHub Pages        uses: peaceiris/actions-gh-pages@v4        with:          github_token: $&#123;&#123; secrets.BLOG_TOKEN &#125;&#125;          publish_dir: ./public\n","slug":"2025-07-18-01","date":"2025-07-18T10:38:36.000Z","categories_index":"GitHub","tags_index":"GitHub","author_index":"Reverse"}]